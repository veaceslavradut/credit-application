<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BankMarketAnalysisService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Credit Application Platform</a> &gt; <a href="index.source.html" class="el_package">com.creditapp.bank.service</a> &gt; <span class="el_source">BankMarketAnalysisService.java</span></div><h1>BankMarketAnalysisService.java</h1><pre class="source lang-java linenums">package com.creditapp.bank.service;

import com.creditapp.bank.dto.*;
import com.creditapp.bank.exception.InsufficientMarketDataException;
import com.creditapp.bank.model.BankRateCard;
import com.creditapp.bank.repository.BankRateCardRepository;
import com.creditapp.borrower.model.Currency;
import com.creditapp.borrower.model.LoanType;
import org.springframework.stereotype.Service;
import org.springframework.cache.annotation.Cacheable;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class BankMarketAnalysisService {

    private static final int MINIMUM_BANKS_FOR_ANALYSIS = 3;
    
    private final BankRateCardRepository rateCardRepository;

<span class="fc" id="L25">    public BankMarketAnalysisService(BankRateCardRepository rateCardRepository) {</span>
<span class="fc" id="L26">        this.rateCardRepository = rateCardRepository;</span>
<span class="fc" id="L27">    }</span>

    @Cacheable(value = &quot;bankMarketAnalysis&quot;, key = &quot;#bankId.toString()&quot;)
    public MarketAnalysisDTO analyzeMarket(UUID bankId) {
        // Fetch all active rate cards for this bank (valid_to IS NULL)
<span class="fc" id="L32">        List&lt;BankRateCard&gt; myRateCards = rateCardRepository.findByBankIdAndValidToIsNull(bankId);</span>
        
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">        if (myRateCards.isEmpty()) {</span>
<span class="nc" id="L35">            throw new IllegalArgumentException(&quot;No active rate cards found for bank&quot;);</span>
        }

<span class="fc" id="L38">        List&lt;MyBankRateCardDTO&gt; myBankRates = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L39">        List&lt;MarketAverageDTO&gt; marketAverages = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L40">        Set&lt;UUID&gt; allBankIds = new HashSet&lt;&gt;();</span>

        // Analyze each rate card
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for (BankRateCard myCard : myRateCards) {</span>
            // Get market data for this loan type and currency
<span class="fc" id="L45">            MarketAverageDTO marketAvg = calculateMarketAverage(myCard.getLoanType(), myCard.getCurrency());</span>
<span class="fc" id="L46">            marketAverages.add(marketAvg);</span>
            
                // Calculate percentile ranking using currently active cards filtered by loanType + currency
<span class="fc" id="L49">                List&lt;BankRateCard&gt; activeCards = rateCardRepository.findByValidToIsNull();</span>
<span class="fc" id="L50">                List&lt;BankRateCard&gt; competitorCards = activeCards.stream()</span>
<span class="pc bpc" id="L51" title="1 of 4 branches missed.">                    .filter(c -&gt; c.getLoanType() == myCard.getLoanType() &amp;&amp; c.getCurrency() == myCard.getCurrency())</span>
<span class="fc" id="L52">                    .collect(Collectors.toList());</span>
                // Collect bank IDs for privacy check (for this market subset)
<span class="fc" id="L54">                Set&lt;UUID&gt; marketBankIds = competitorCards.stream()</span>
<span class="fc" id="L55">                    .map(BankRateCard::getBankId)</span>
<span class="fc" id="L56">                    .collect(Collectors.toSet());</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">                if (marketBankIds.size() &lt; MINIMUM_BANKS_FOR_ANALYSIS) {</span>
<span class="fc" id="L58">                throw new InsufficientMarketDataException(</span>
<span class="fc" id="L59">                    String.format(&quot;Insufficient market data: only %d banks found, minimum %d required&quot;,</span>
<span class="fc" id="L60">                        marketBankIds.size(), MINIMUM_BANKS_FOR_ANALYSIS));</span>
                }
                // Track all unique bank IDs encountered (for response metadata)
<span class="fc" id="L63">                allBankIds.addAll(marketBankIds);</span>
            
<span class="fc" id="L65">            List&lt;BigDecimal&gt; allAprs = competitorCards.stream()</span>
<span class="fc" id="L66">                    .map(BankRateCard::getBaseApr)</span>
<span class="fc" id="L67">                    .collect(Collectors.toList());</span>
            
<span class="fc" id="L69">            Integer percentile = calculatePercentileRanking(myCard.getBaseApr(), allAprs);</span>
<span class="fc" id="L70">            CompetitivePosition position = determineCompetitivePosition(percentile);</span>
            
<span class="fc" id="L72">            MyBankRateCardDTO myBankRate = new MyBankRateCardDTO(</span>
<span class="fc" id="L73">                    myCard.getLoanType(),</span>
<span class="fc" id="L74">                    myCard.getCurrency(),</span>
<span class="fc" id="L75">                    myCard.getBaseApr(),</span>
<span class="fc" id="L76">                    percentile,</span>
<span class="fc" id="L77">                    position,</span>
<span class="fc" id="L78">                    myCard.getOriginationFeePercent(),</span>
<span class="fc" id="L79">                    myCard.getInsurancePercent(),</span>
<span class="fc" id="L80">                    myCard.getProcessingTimeDays()</span>
            );
<span class="fc" id="L82">            myBankRates.add(myBankRate);</span>
        }

        // Calculate overall competitive position (average of all percentiles)
<span class="fc" id="L86">        double avgPercentile = myBankRates.stream()</span>
<span class="fc" id="L87">                .mapToInt(MyBankRateCardDTO::marketPercentileRanking)</span>
<span class="fc" id="L88">                .average()</span>
<span class="fc" id="L89">                .orElse(50.0);</span>
        
<span class="fc" id="L91">        CompetitivePosition overallPosition = determineCompetitivePosition((int) Math.round(avgPercentile));</span>

<span class="fc" id="L93">        MarketVisualizationDTO visualization = buildVisualizationData(myBankRates, marketAverages);</span>
<span class="fc" id="L94">        return new MarketAnalysisDTO(</span>
<span class="fc" id="L95">            myBankRates,</span>
<span class="fc" id="L96">            marketAverages,</span>
<span class="fc" id="L97">            overallPosition.name(),</span>
<span class="fc" id="L98">            LocalDateTime.now(),</span>
<span class="fc" id="L99">            allBankIds.size(),</span>
<span class="fc" id="L100">            visualization</span>
        );
    }

    @Cacheable(value = &quot;marketAverage&quot;, key = &quot;#loanType.name() + ':' + #currency.name()&quot;)
    public MarketAverageDTO calculateMarketAverage(LoanType loanType, Currency currency) {
        // Use active rate cards (valid_to IS NULL) and filter by loanType + currency
<span class="fc" id="L107">        List&lt;BankRateCard&gt; marketCards = rateCardRepository</span>
<span class="fc" id="L108">                .findByValidToIsNull()</span>
<span class="fc" id="L109">                .stream()</span>
<span class="pc bpc" id="L110" title="1 of 4 branches missed.">                .filter(c -&gt; c.getLoanType() == loanType &amp;&amp; c.getCurrency() == currency)</span>
<span class="fc" id="L111">                .collect(Collectors.toList());</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (marketCards.isEmpty()) {</span>
<span class="nc" id="L114">            return new MarketAverageDTO(loanType, currency, BigDecimal.ZERO, BigDecimal.ZERO,</span>
<span class="nc" id="L115">                    BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, BigDecimal.ZERO, 0, 0);</span>
        }

        // Calculate statistics
<span class="fc" id="L119">        List&lt;BigDecimal&gt; aprs = marketCards.stream()</span>
<span class="fc" id="L120">                .map(BankRateCard::getBaseApr)</span>
<span class="fc" id="L121">                .sorted()</span>
<span class="fc" id="L122">                .collect(Collectors.toList());</span>

<span class="fc" id="L124">        BigDecimal avgApr = aprs.stream()</span>
<span class="fc" id="L125">                .reduce(BigDecimal.ZERO, BigDecimal::add)</span>
<span class="fc" id="L126">                .divide(BigDecimal.valueOf(aprs.size()), 2, RoundingMode.HALF_UP);</span>

<span class="fc" id="L128">        BigDecimal medianApr = calculateMedian(aprs);</span>
<span class="fc" id="L129">        BigDecimal minApr = aprs.get(0);</span>
<span class="fc" id="L130">        BigDecimal maxApr = aprs.get(aprs.size() - 1);</span>

<span class="fc" id="L132">        BigDecimal avgOriginationFee = marketCards.stream()</span>
<span class="fc" id="L133">                .map(BankRateCard::getOriginationFeePercent)</span>
<span class="fc" id="L134">                .reduce(BigDecimal.ZERO, BigDecimal::add)</span>
<span class="fc" id="L135">                .divide(BigDecimal.valueOf(marketCards.size()), 2, RoundingMode.HALF_UP);</span>

<span class="fc" id="L137">        BigDecimal avgInsurance = marketCards.stream()</span>
<span class="fc" id="L138">                .map(BankRateCard::getInsurancePercent)</span>
<span class="fc" id="L139">                .reduce(BigDecimal.ZERO, BigDecimal::add)</span>
<span class="fc" id="L140">                .divide(BigDecimal.valueOf(marketCards.size()), 2, RoundingMode.HALF_UP);</span>

<span class="fc" id="L142">        int avgProcessingTime = (int) marketCards.stream()</span>
<span class="fc" id="L143">                .mapToInt(BankRateCard::getProcessingTimeDays)</span>
<span class="fc" id="L144">                .average()</span>
<span class="fc" id="L145">                .orElse(0);</span>

        // Get unique bank count for privacy
<span class="fc" id="L148">        Set&lt;UUID&gt; uniqueBanks = marketCards.stream()</span>
<span class="fc" id="L149">                .map(BankRateCard::getBankId)</span>
<span class="fc" id="L150">                .collect(Collectors.toSet());</span>

<span class="fc" id="L152">        return new MarketAverageDTO(</span>
<span class="fc" id="L153">                loanType,</span>
<span class="fc" id="L154">                currency,</span>
<span class="fc" id="L155">                avgApr,</span>
<span class="fc" id="L156">                medianApr,</span>
<span class="fc" id="L157">                minApr,</span>
<span class="fc" id="L158">                maxApr,</span>
<span class="fc" id="L159">                avgOriginationFee,</span>
<span class="fc" id="L160">                avgInsurance,</span>
<span class="fc" id="L161">                avgProcessingTime,</span>
<span class="fc" id="L162">                uniqueBanks.size()</span>
        );
    }

    public Integer calculatePercentileRanking(BigDecimal myApr, List&lt;BigDecimal&gt; allAprs) {
        // Sort APRs ascending (lowest to highest)
<span class="fc" id="L168">        List&lt;BigDecimal&gt; sortedAprs = allAprs.stream()</span>
<span class="fc" id="L169">                .sorted()</span>
<span class="fc" id="L170">                .collect(Collectors.toList());</span>

<span class="fc" id="L172">        int total = sortedAprs.size();</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (total == 0) return 0;</span>

        // Determine position (1-based) as count of APRs strictly less than myApr, then +1
<span class="fc" id="L176">        int lessCount = 0;</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        for (BigDecimal apr : sortedAprs) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            if (apr.compareTo(myApr) &lt; 0) {</span>
<span class="fc" id="L179">                lessCount++;</span>
            } else {
                break;
            }
        }
<span class="fc" id="L184">        int position = lessCount + 1;</span>

        // Lower APR = better = higher percentile (invert ranking)
<span class="fc" id="L187">        return Math.round(((float) (total - position + 1) / total) * 100);</span>
    }

    public CompetitivePosition determineCompetitivePosition(Integer percentile) {
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (percentile &gt;= 75) {</span>
<span class="fc" id="L192">            return CompetitivePosition.MORE_COMPETITIVE;</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        } else if (percentile &gt;= 25) {</span>
<span class="fc" id="L194">            return CompetitivePosition.AVERAGE;</span>
        } else {
<span class="nc" id="L196">            return CompetitivePosition.LESS_COMPETITIVE;</span>
        }
    }

    private BigDecimal calculateMedian(List&lt;BigDecimal&gt; sortedValues) {
<span class="fc" id="L201">        int size = sortedValues.size();</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        if (size == 0) {</span>
<span class="nc" id="L203">            return BigDecimal.ZERO;</span>
        }
        
<span class="fc bfc" id="L206" title="All 2 branches covered.">        if (size % 2 == 1) {</span>
<span class="fc" id="L207">            return sortedValues.get(size / 2);</span>
        } else {
<span class="fc" id="L209">            BigDecimal mid1 = sortedValues.get(size / 2 - 1);</span>
<span class="fc" id="L210">            BigDecimal mid2 = sortedValues.get(size / 2);</span>
<span class="fc" id="L211">            return mid1.add(mid2).divide(BigDecimal.valueOf(2), 2, RoundingMode.HALF_UP);</span>
        }
    }

        private MarketVisualizationDTO buildVisualizationData(List&lt;MyBankRateCardDTO&gt; myBankRates,
                                  List&lt;MarketAverageDTO&gt; marketAverages) {
<span class="fc" id="L217">        Map&lt;String, MarketAverageDTO&gt; avgByKey = marketAverages.stream()</span>
<span class="fc" id="L218">            .collect(Collectors.toMap(</span>
<span class="fc" id="L219">                m -&gt; m.loanType().name() + &quot;:&quot; + m.currency().name(),</span>
<span class="fc" id="L220">                m -&gt; m</span>
            ));

<span class="fc" id="L223">        List&lt;MarketVisualizationDTO.AprComparisonItem&gt; apr = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L224">        List&lt;MarketVisualizationDTO.FeeComparisonItem&gt; fees = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L225">        List&lt;MarketVisualizationDTO.ProcessingTimeComparisonItem&gt; times = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (MyBankRateCardDTO my : myBankRates) {</span>
<span class="fc" id="L228">            String key = my.loanType().name() + &quot;:&quot; + my.currency().name();</span>
<span class="fc" id="L229">            MarketAverageDTO avg = avgByKey.get(key);</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (avg == null) continue;</span>

<span class="fc" id="L232">                apr.add(new MarketVisualizationDTO.AprComparisonItem(</span>
<span class="fc" id="L233">                my.loanType(), my.currency(),</span>
<span class="fc" id="L234">                my.baseApr(), avg.medianApr(), avg.minApr(), avg.maxApr()</span>
            ));

<span class="fc" id="L237">                fees.add(new MarketVisualizationDTO.FeeComparisonItem(</span>
<span class="fc" id="L238">                my.loanType(), my.currency(),</span>
<span class="fc" id="L239">                my.originationFeePercent(), avg.averageOriginationFee(),</span>
<span class="fc" id="L240">                my.insurancePercent(), avg.averageInsuranceCost()</span>
            ));

<span class="fc" id="L243">                times.add(new MarketVisualizationDTO.ProcessingTimeComparisonItem(</span>
<span class="fc" id="L244">                my.loanType(), my.currency(),</span>
<span class="fc" id="L245">                my.processingTimeDays(), avg.averageProcessingTime()</span>
            ));
        }

<span class="fc" id="L249">        return new MarketVisualizationDTO(apr, fees, times);</span>
        }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>