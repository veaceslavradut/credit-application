# Story 2.4: Edit Borrower Application

## Status
Ready for Development

## Story

**As a** borrower,
**I want** to edit my loan application details before submitting it,
**so that** I can correct errors or add more information (financial details) to improve my chances of approval.

## Acceptance Criteria

1. PUT /api/borrower/applications/{applicationId} endpoint updates DRAFT application
2. Can edit: loan_type, loan_amount (100-1000000), loan_term_months (6-360), currency, rate_preference, application_details (income, employment, down payment)
3. Can only edit applications in DRAFT status (returns 409 Conflict if already submitted)
4. Validation: same rules as create (loan_amount, term_months ranges)
5. Response returns updated ApplicationDTO with all changes
6. Only borrower who owns the application can edit it (403 Forbidden otherwise)
7. Tracks edit history: logs edit event with old vs new values
8. Optimistic locking: prevent concurrent edits (version field, 409 Conflict if stale)
9. Integration test: create app, list, edit application details, verify changes persisted
10. No rate limiting on edit (unlike create)

## Tasks / Subtasks

- [ ] Task 1: Add Version Field to Application Entity (AC: 8)
  - [ ] Update Application entity with @Version field (Long)
    - @Version annotation for optimistic locking
    - Incremented on each update
    - JPA handles version checking automatically
  - [ ] Create database migration to add version column to applications table
    - ALTER TABLE applications ADD COLUMN version BIGINT DEFAULT 1;
  - [ ] Unit tests: verify version increments on update

- [ ] Task 2: Create Update Application Request DTO (AC: 2, 4)
  - [ ] Create UpdateApplicationRequest DTO (src/main/java/com/creditapp/borrower/dto/UpdateApplicationRequest.java)
    - Fields: loanType (optional), loanAmount (optional), loanTermMonths (optional), currency (optional), ratePreference (optional), applicationDetails (optional)
    - applicationDetails: annualIncome, employmentStatus, downPaymentAmount
    - Validations: @DecimalMin(100), @Min(6), @Max(1000000/360) for ranges
    - At least one field must be provided (non-empty update)
  - [ ] Create UpdateApplicationResponse DTO
    - Fields: id, loanType, loanAmount, loanTermMonths, currency, ratePreference, status, version, updatedAt, editedFields (List<String> tracking which fields changed)
  - [ ] Unit tests: test valid and invalid request payloads

- [ ] Task 3: Create Application Update Service (AC: 2, 3, 4, 5, 7)
  - [ ] Create or extend ApplicationService: updateApplication(UUID applicationId, UUID borrowerId, UpdateApplicationRequest request) returns UpdateApplicationResponse
    - Verify borrower owns application (access control)
    - Verify application status == DRAFT (throw ApplicationNotEditableException if not)
    - Validate all provided fields (loan_amount, term_months ranges)
    - Track old values before update (for change logging)
    - Update fields: loanType, loanAmount, loanTermMonths, currency, ratePreference
    - Handle ApplicationDetails: create if not exists, update if exists
    - Save to ApplicationRepository (JPA handles version increment)
    - Catch OptimisticLockingFailureException, throw ApplicationStaleException (409)
    - Log APPLICATION_UPDATED audit event with old vs new values
    - Return UpdateApplicationResponse with list of changed fields
    - Error handling:
      - ApplicationNotFoundException (404)
      - AccessDeniedException (403) - different borrower
      - ApplicationNotEditableException (409) - not DRAFT status
      - ApplicationStaleException (409) - version conflict (optimistic lock)
      - InvalidApplicationException (400) - validation failure
  - [ ] Unit tests: mock repository, test status check, test validation, test optimistic locking

- [ ] Task 4: Create Update Endpoint (AC: 1, 3, 5, 6, 8)
  - [ ] Add PUT endpoint in BorrowerApplicationController: PUT /api/borrower/applications/{applicationId}
    - @PreAuthorize("hasAuthority('BORROWER')")
    - Path parameter: applicationId (UUID)
    - Request body: @Valid UpdateApplicationRequest
    - Extract borrowerId from SecurityContext
    - Call ApplicationService.updateApplication(applicationId, borrowerId, request)
    - Return: ResponseEntity<UpdateApplicationResponse> with HTTP 200 OK
    - Response includes: id, all updated fields, version, updatedAt, editedFields list
    - Error handling:
      - 400 Bad Request: validation failures
      - 401 Unauthorized: not authenticated
      - 403 Forbidden: not borrower or access denied
      - 404 Not Found: application doesn't exist
      - 409 Conflict: not DRAFT status OR version conflict (optimistic lock)
      - 500 Internal Server Error: unexpected failures
    - Controller logs: borrowerId, applicationId, fields changed, status (success/failure)
  - [ ] Unit tests: mock service, test success and error paths
  - [ ] Integration tests: real HTTP requests with JWT token

- [ ] Task 5: Implement Optimistic Locking (AC: 8)
  - [ ] Verify @Version field in Application entity with JPA
  - [ ] Spring Data JPA automatically handles version checking on update
  - [ ] Create ApplicationStaleException (extends RuntimeException)
    - Thrown when OptimisticLockingFailureException caught from JPA
    - Indicates version mismatch (concurrent modification)
  - [ ] Add exception handler to GlobalExceptionHandler
    - @ExceptionHandler for ApplicationStaleException  409 Conflict
    - Response: { "error": "Stale Update", "message": "Application was modified by another request. Please refresh and try again.", "currentVersion": 5 }
  - [ ] Unit tests: mock repository to throw OptimisticLockingFailureException

- [ ] Task 6: Add Audit Logging for Edits (AC: 7)
  - [ ] Ensure ApplicationService logs to AuditService:
    - Event: APPLICATION_UPDATED
    - Fields: borrower_id, application_id, edited_fields (List), old_values (Map), new_values (Map)
    - Include all fields that changed with before/after values
    - Format: { "income": {"old": null, "new": 75000}, "employment": {"old": null, "new": "EMPLOYED"} }
  - [ ] Verify AuditService writes to audit log table (Story 1.7 prerequisite)
  - [ ] Test: verify audit log entry created with all changed field details

- [ ] Task 7: Create Unit Tests (AC: 4, 8)
  - [ ] Create ApplicationUpdateServiceTest (src/test/java/com/creditapp/unit/borrower/ApplicationUpdateServiceTest.java)
    - Test 1: Happy path - update single field, verify persisted
    - Test 2: Update multiple fields, verify all changes saved
    - Test 3: Update loanAmount to invalid value (50), verify validation failure
    - Test 4: Update loanTermMonths to invalid value (361), verify validation failure
    - Test 5: Update SUBMITTED application, verify ApplicationNotEditableException
    - Test 6: Update application with stale version, verify OptimisticLockingFailureException
    - Test 7: Create/update ApplicationDetails in same request, verify persisted
    - Test 8: Update application owned by different borrower, verify AccessDeniedException
    - Test 9: Verify ApplicationService calls AuditService.logEvent() with APPLICATION_UPDATED
    - Test 10: Verify response includes editedFields list with changed field names
  - [ ] Mock: ApplicationRepository, ApplicationDetailsRepository, AuditService
  - [ ] Framework: JUnit 5, Mockito

- [ ] Task 8: Create Access Control Tests (AC: 6, 8)
  - [ ] Create ApplicationUpdateAccessControlTest
    - Test 1: Borrower A edit own DRAFT application, verify 200 OK
    - Test 2: Borrower A edit Borrower B's application, verify 403 Forbidden
    - Test 3: Non-BORROWER role (BANK_ADMIN) edit application, verify 403 Forbidden
    - Test 4: Unauthenticated PUT request, verify 401 Unauthorized
    - Test 5: Edit submitted application (status != DRAFT), verify 409 Conflict
  - [ ] Use Spring Security Test with @WithMockUser

- [ ] Task 9: Create Integration Tests (AC: 1, 2, 3, 5, 6, 8, 9)
  - [ ] Create ApplicationUpdateIntegrationTest (src/test/java/com/creditapp/integration/borrower/ApplicationUpdateIntegrationTest.java)
    - Setup: Create borrower, create DRAFT application with Story 2.2
    - Test 1: PUT to update loanAmount, verify 200 OK with updated value
    - Test 2: PUT with updated application details (income, employment), verify persisted
    - Test 3: PUT update loanType and currency together, verify all changes
    - Test 4: PUT with invalid loanAmount (50), verify 400 Bad Request
    - Test 5: PUT with invalid loanTermMonths (361), verify 400 Bad Request
    - Test 6: Create app, submit it, PUT to edit, verify 409 Conflict (not DRAFT)
    - Test 7: Optimistic lock test: fetch app (v=1), fetch again in another context (v=1), update first (v=2), update second, verify second gets 409
    - Test 8: Borrower A edit, Borrower B PUT to same app, verify 403 Forbidden
    - Test 9: PUT non-existent application, verify 404 Not Found
    - Test 10: PUT returns updated ApplicationDTO with version incremented
    - Test 11: Verify LIST returns updated values (from Story 2.3)
    - Test 12: Verify GET details endpoint returns updated values (from Story 2.3)
    - Test 13: Verify audit log entry created with APPLICATION_UPDATED event
    - Test 14: Verify audit log includes old vs new values for each field changed
  - [ ] Use: TestContainers (PostgreSQL), TestRestTemplate, @WithMockUser for auth
  - [ ] Database: Real database with applications from Story 2.2 and 2.3

- [ ] Task 10: Create Validation Tests (AC: 2, 4)
  - [ ] Create ApplicationUpdateValidationTest
    - Test 1: Empty request body (no fields), verify 400 Bad Request with "at least one field required"
    - Test 2: loanAmount=99, verify validation error (minimum 100)
    - Test 3: loanAmount=1000001, verify validation error (maximum 1000000)
    - Test 4: loanTermMonths=5, verify validation error (minimum 6)
    - Test 5: loanTermMonths=361, verify validation error (maximum 360)
    - Test 6: Invalid enum value for loanType, verify 400 Bad Request
    - Test 7: Null/empty required field (when provided), verify validation failure
  - [ ] Framework: JUnit 5, Spring validation testing

- [ ] Task 11: Create Concurrency Tests (AC: 8)
  - [ ] Create ApplicationUpdateConcurrencyTest
    - Test 1: Two concurrent PUTs to same application, second fails with 409
    - Test 2: Simulate optimistic lock by manually incrementing version in database
    - Test 3: Verify error response includes "Stale Update" message and current version
  - [ ] Use: TestContainers, multithreading simulation or sequential version checking

- [ ] Task 12: Create API Documentation (AC: 1, 2, 5)
  - [ ] Update docs/API_ENDPOINTS.md
    - PUT /api/borrower/applications/{applicationId}
      - Authentication: Bearer {JWT token}, BORROWER role required
      - Path parameter: applicationId (UUID)
      - Request body:
        `json
        {
          "loanAmount": 35000,
          "loanTermMonths": 48,
          "ratePreference": "FIXED",
          "applicationDetails": {
            "annualIncome": 75000,
            "employmentStatus": "EMPLOYED",
            "downPaymentAmount": 5000
          }
        }
        `
      - Response (200 OK):
        `json
        {
          "id": "550e8400-e29b-41d4-a716-446655440000",
          "loanType": "PERSONAL",
          "loanAmount": 35000,
          "loanTermMonths": 48,
          "currency": "EUR",
          "ratePreference": "FIXED",
          "status": "DRAFT",
          "version": 2,
          "updatedAt": "2026-01-15T14:45:00Z",
          "editedFields": ["loanAmount", "loanTermMonths", "ratePreference", "applicationDetails"]
        }
        `
      - Error responses:
        - 400 Bad Request: validation failures, empty request
        - 401 Unauthorized: not authenticated
        - 403 Forbidden: not borrower or access denied
        - 404 Not Found: application doesn't exist
        - 409 Conflict: application not DRAFT OR version conflict
      - Optimistic locking note: Version field prevents concurrent edits

- [ ] Task 13: Create Field Change Tracking (AC: 7)
  - [ ] Implement change tracking in ApplicationService.updateApplication()
    - Before update: capture old values of all fields
    - After update: capture new values
    - Calculate changed fields (compare old vs new)
    - Include in response: editedFields list
    - Include in audit log: old_values, new_values maps
  - [ ] Unit tests: verify only changed fields listed, unchanged fields excluded

- [ ] Task 14: Test Full Edit Workflow (AC: 1, 2, 3, 5, 6, 9)
  - [ ] Create ApplicationEditWorkflowTest
    - Test 1: Create app  List apps (verify v=1)  Edit app  List apps (verify changes)
    - Test 2: Create app  View details  Edit details  View details (verify updated)
    - Test 3: Create app with minimal info  Edit to add financial details  Verify details available
    - Test 4: Create app  Edit multiple times  Verify version increments and all edits persisted
    - Test 5: Create app  Edit  View history (verify edit event appears)
  - [ ] Integration test combining Stories 2.2, 2.3, 2.4

## Dev Notes

### Previous Stories Dependencies
- **Story 2.1**: Application entity, repositories, DTOs
- **Story 2.2**: CreateApplicationService, application creation
- **Story 2.3**: ListApplicationsService, view endpoints (verify updates appear in lists)
- **Story 1.6**: RBAC - @PreAuthorize("hasAuthority('BORROWER')")
- **Story 1.7**: AuditService for logging

### Technology Stack
[Source: architecture/1-system-architecture-overview.md]
- **Framework**: Spring Boot 3.2.1, Spring Data JPA
- **Concurrency**: JPA @Version for optimistic locking
- **Validation**: Spring Validation, Hibernate Validator
- **Testing**: JUnit 5, Mockito, TestContainers

### Optimistic Locking Pattern
[Source: JPA best practices]
- **@Version field**: Long type, incremented by JPA on each update
- **Conflict Detection**: OptimisticLockingFailureException when version mismatch
- **Client Handling**: Return 409 Conflict with current version, client can refresh and retry
- **Use Case**: Prevent lost updates in concurrent edit scenarios

### Update Semantics
[Source: REST API standards]
- **PUT Semantics**: Full or partial update (idempotent if same input)
- **Partial Updates**: Only provided fields updated, others unchanged
- **At Least One Field**: Require at least one field in request to prevent empty updates
- **Validation**: Same rules as creation for any field being updated

### Change Tracking
[Source: Audit requirements]
- **Old vs New Values**: Log both for audit trail
- **Changed Fields Only**: Only track fields that actually changed (avoid noise)
- **Audit Entry**: Include APPLICATION_UPDATED event with field-level changes
- **Response**: Include editedFields list for UI feedback

### Application Edit Restrictions
[Source: Architecture requirements]
- **DRAFT Only**: Can only edit applications in DRAFT status
- **Submitted Lock**: Once SUBMITTED, cannot edit (prevents stale data in underwriting)
- **Submitted Workflow**: Must withdraw and recreate if need to change submitted app
- **Status Constraint**: 409 Conflict if attempting to edit non-DRAFT app

### Project Directory Structure
[Source: Story 1.1 context]
`
src/main/java/com/creditapp/
 borrower/
    controller/        # BorrowerApplicationController.java (add PUT endpoint)
    service/           # ApplicationService.java (add updateApplication method)
    dto/               # UpdateApplicationRequest.java, UpdateApplicationResponse.java
    exception/         # ApplicationNotEditableException.java, ApplicationStaleException.java
 shared/
    exception/         # GlobalExceptionHandler.java (add handlers for new exceptions)
    audit/             # AuditService.java (from Story 1.7, called here)

src/test/java/com/creditapp/
 unit/
    borrower/
      ApplicationUpdateServiceTest.java
      ApplicationUpdateAccessControlTest.java
      ApplicationUpdateValidationTest.java
      ApplicationUpdateConcurrencyTest.java
 integration/
    borrower/
      ApplicationUpdateIntegrationTest.java
      ApplicationEditWorkflowTest.java
`

### Testing Standards
[Source: frontend-architecture/10-testing-strategy.md]
- **Unit Tests**: Mock repositories, test service logic, validation, optimistic locking
- **Integration Tests**: Real database (TestContainers), real HTTP client, concurrency scenarios
- **Test Coverage**: All update paths, validation rules, access control, concurrency
- **Test Location**: src/test/java/com/creditapp/unit/borrower/, src/test/java/com/creditapp/integration/borrower/

### Important Notes
1. **Version Field**: Required for optimistic locking; JPA handles incrementing
2. **DRAFT Only**: Enforce status check before allowing updates
3. **Partial Updates**: Only update fields provided in request
4. **Validation**: Apply same validation rules as creation (loan_amount, term_months)
5. **Concurrency**: Handle OptimisticLockingFailureException gracefully (409 response)
6. **Audit Trail**: Log all changes with old vs new values for compliance
7. **Change Tracking**: Include editedFields list in response for UI feedback
8. **Access Control**: Verify borrower owns application before updating
9. **No Rate Limiting**: Unlike creation (Story 2.2), edits have no rate limit
10. **Error Messages**: Be specific about validation failures and conflict reasons

## Testing

### Testing Framework & Location
- **Framework**: JUnit 5, Spring Boot Test, Spring Security Test, TestContainers
- **HTTP Client**: TestRestTemplate
- **Mocking**: Mockito
- **Concurrency**: ExecutorService for multi-threaded tests
- **Test Location**: src/test/java/com/creditapp/unit/borrower/, src/test/java/com/creditapp/integration/borrower/

### Testing Checklist
- [ ] UpdateApplicationRequest DTO validates all fields correctly
- [ ] UpdateApplicationRequest requires at least one field
- [ ] ApplicationService validates loan_amount (100-1000000)
- [ ] ApplicationService validates loan_term_months (6-360)
- [ ] ApplicationService checks application status == DRAFT before updating
- [ ] ApplicationService calls AuditService.logEvent() with APPLICATION_UPDATED
- [ ] ApplicationService tracks old vs new values in audit log
- [ ] Optimistic locking: OptimisticLockingFailureException handled as 409 Conflict
- [ ] Version field increments on each successful update
- [ ] BorrowerApplicationController PUT returns 200 OK with updated ApplicationDTO
- [ ] BorrowerApplicationController PUT includes editedFields list in response
- [ ] PUT requires @PreAuthorize BORROWER role
- [ ] GlobalExceptionHandler returns 400 for validation failures
- [ ] GlobalExceptionHandler returns 409 for ApplicationNotEditableException (not DRAFT)
- [ ] GlobalExceptionHandler returns 409 for ApplicationStaleException (version conflict)
- [ ] Integration test: create app, edit, verify persisted in database
- [ ] Integration test: edit DRAFT app succeeds, edit submitted app fails (409)
- [ ] Integration test: concurrent edits - second fails with 409
- [ ] Integration test: access control - different borrower gets 403
- [ ] Integration test: LIST endpoint reflects updated values
- [ ] Integration test: GET details endpoint reflects updated values
- [ ] Audit logging: APPLICATION_UPDATED event logged with field changes
- [ ] Audit logging: includes old and new values for each field
- [ ] Validation: empty request body returns 400
- [ ] Validation: invalid enum values return 400
- [ ] All tests pass with \mvn clean test\
- [ ] Code coverage >80%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-15 | 1.0 | Initial story draft - Edit Borrower Application | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be completed by development agent*

### Debug Log References
*To be completed by development agent*

### Completion Notes
*To be completed by development agent*

### File List
*To be completed by development agent*

## QA Results

*To be completed by QA agent after story is implemented*
