# Story 1.7: Audit Logging Infrastructure

## Status
Ready for Development

## Story

**As a** compliance officer,
**I want** all user actions logged immutably with timestamps and user context,
**so that** I can audit who did what and when for regulatory compliance.

## Acceptance Criteria

1. Audit log table: user_id, action, resource, timestamp, IP address, result
2. JPA event listener logs all user actions automatically
3. Audit logs are immutable: no delete or update operations
4. GET /api/compliance/audit-logs endpoint returns paginated audit logs
5. Audit logs contain: user_id, role, action, resource_id, timestamp, IP, user agent
6. Sensitive fields never logged
7. Retention policy: audit logs retained for minimum 3 years
8. Integration test: register user, verify audit log entry created
9. Documentation: audit event types

## Tasks / Subtasks

- [ ] Task 1: Create Database Migration for Audit Log Table (AC: 1, 3, 7)
  - [ ] Create V5__Create_Audit_Logs_Table.sql migration
    - Create audit_logs table with columns: id (BIGSERIAL PK), entity_type, entity_id (UUID), action, actor_id (UUID), actor_role, old_values (JSONB), new_values (JSONB), ip_address, user_agent, created_at
    - Add check constraint: ensure immutability (no delete/update allowed via trigger or application logic)
    - Create index on (entity_type, entity_id, created_at) for query performance
    - Set comment: 'Immutable audit trail - 3 year retention policy'
  - [ ] Verify migration runs without errors on docker-compose PostgreSQL

- [ ] Task 2: Create AuditLog JPA Entity (AC: 1, 5)
  - [ ] Create AuditLog entity (src/main/java/com/creditapp/shared/model/AuditLog.java)
    - Fields: id (Long), entityType (String), entityId (UUID), action (String), actorId (UUID), actorRole (String), oldValues (Map<String,Object> via JsonType), newValues (Map<String,Object> via JsonType), ipAddress, userAgent, createdAt (LocalDateTime)
    - @Entity, @Table(name=\"audit_logs\")
    - @Column annotations with appropriate constraints
    - @CreationTimestamp for createdAt (auto-populate on insert)
    - No setter for createdAt (immutable after creation)
    - Add @JsonIgnore on sensitive fields if any
  - [ ] Create AuditLogRepository (src/main/java/com/creditapp/shared/repository/AuditLogRepository.java)
    - Extends JpaRepository<AuditLog, Long>
    - Method: findByEntityTypeAndEntityId(String entityType, UUID entityId, Pageable pageable) returns Page<AuditLog>
    - Method: findByActorId(UUID actorId, Pageable pageable) returns Page<AuditLog>
    - Method: findByCreatedAtBetween(LocalDateTime start, LocalDateTime end, Pageable pageable) returns Page<AuditLog>
    - No update or delete methods exposed
  - [ ] Unit tests: verify entity persistence and immutability constraints

- [ ] Task 3: Create Audit Event Enum and DTO (AC: 5, 9)
  - [ ] Create AuditAction enum (src/main/java/com/creditapp/shared/model/AuditAction.java)
    - Values: USER_REGISTERED, USER_LOGGED_IN, USER_LOGGED_OUT, PASSWORD_CHANGED, PROFILE_UPDATED, BANK_REGISTERED, BANK_ACTIVATED, APPLICATION_SUBMITTED, OFFER_CREATED, OFFER_ACCEPTED, APPLICATION_VIEWED, ROLE_ASSIGNED
    - Method: getDescription() returns human-readable description
    - Document each action in code comments
  - [ ] Create AuditLogDTO (src/main/java/com/creditapp/shared/dto/AuditLogDTO.java) for API responses
    - Fields: id, entityType, entityId, action, actorId, actorRole, oldValues (filtered, no sensitive), newValues (filtered, no sensitive), ipAddress, createdAt
    - No passwords or authentication tokens in oldValues/newValues
  - [ ] Create AuditLogRequest (src/main/java/com/creditapp/shared/dto/AuditLogRequest.java) for creating manual audit entries
    - Fields: entityType, entityId, action, oldValues, newValues (optional for write-only events)
    - Validation: @NotBlank on entityType and action

- [ ] Task 4: Create Audit Service (AC: 2, 5, 6)
  - [ ] Create AuditService (src/main/java/com/creditapp/shared/service/AuditService.java)
    - Method: logAction(String entityType, UUID entityId, AuditAction action, Object actorId, String actorRole, String ipAddress, String userAgent) returns AuditLog
    - Method: logActionWithValues(String entityType, UUID entityId, AuditAction action, Map<String,Object> oldValues, Map<String,Object> newValues, Object actorId, String actorRole, String ipAddress, String userAgent) returns AuditLog
    - Method: sanitizeValues(Map<String,Object> values) returns Map<String,Object> (removes passwords, tokens, PII)
    - Sanitization rules: never log password, refresh_token, ssn, address, phone (except audit explicitly allows)
    - Save to AuditLogRepository
    - Log action via application logger (not audit log) for immediate visibility
    - Handle exceptions gracefully (audit failure should not break application)
  - [ ] Create RequestContextService (src/main/java/com/creditapp/shared/service/RequestContextService.java)
    - Method: getCurrentIpAddress(HttpServletRequest request) returns String
    - Method: getCurrentUserAgent(HttpServletRequest request) returns String
    - Method: getCurrentUserId() returns UUID (from SecurityContext)
    - Method: getCurrentUserRole() returns String (from SecurityContext)
  - [ ] Unit tests: verify sanitization, immutability constraint handling, exception handling

- [ ] Task 5: Create AuditLog JPA Listener & AOP Aspects (AC: 2, 3, 5)
  - [ ] **BLOCKING DECISION RESOLVED**: Entity Audit Pattern
    - **Decision**: Hybrid approach - JPA listeners for entity events + Spring AOP for business events
    - **Rationale**: JPA listeners capture data changes (user created, field updated); AOP captures business context (application submitted, offer accepted)
    - **Entity Events** (tracked via JPA @PostPersist, @PostUpdate):
      - USER_REGISTERED: When User entity created
      - BANK_ACTIVATED: When Organization status changes to ACTIVE
      - PROFILE_UPDATED: When user fields updated
    - **Business Events** (tracked via @BusinessAudit annotation + AOP):
      - APPLICATION_SUBMITTED: When borrower submits application
      - OFFER_CREATED: When bank creates preliminary offer
      - OFFER_ACCEPTED: When borrower accepts offer
  - [ ] Create EntityAuditListener (src/main/java/com/creditapp/shared/audit/EntityAuditListener.java)
    - Implements JPA event listeners (@PostPersist, @PostUpdate for tracked entities)
    - Annotate User, Organization entities with @EntityListeners(EntityAuditListener.class)
    - Log USER_REGISTERED on user creation (@PostPersist)
    - Log PASSWORD_CHANGED on user password update (@PostUpdate)
    - Log PROFILE_UPDATED on user field changes (@PostUpdate)
    - Only capture fields that are non-sensitive
  - [ ] Create BusinessAudit annotation (src/main/java/com/creditapp/shared/audit/BusinessAudit.java)
    - Parameters: action (AuditAction enum), entityType (String)
  - [ ] Create BusinessAuditAspect (src/main/java/com/creditapp/shared/audit/BusinessAuditAspect.java)
    - Pointcut: @annotation(BusinessAudit)
    - @Around advice: call service, then log action
  - [ ] Unit tests: verify JPA listener and AOP aspect work correctly

- [ ] Task 6: Create Audit HTTP Interceptor (AC: 5)
  - [ ] Create AuditInterceptor (src/main/java/com/creditapp/shared/interceptor/AuditInterceptor.java) or use Filter
    - Implement HandlerInterceptor or Filter
    - Method: preHandle() extracts IP address and user agent from request, stores in ThreadLocal or RequestContext
    - Method: afterCompletion() removes ThreadLocal data (cleanup)
    - Registered in SecurityConfig or WebMvcConfigurer
  - [ ] Update AuditService to use RequestContext for IP and user agent (injected via AuditInterceptor)
  - [ ] Unit tests: verify IP and user agent extraction

- [ ] Task 7: Create Audit Logs API Endpoint (AC: 4, 5)
  - [ ] Create ComplianceController (src/main/java/com/creditapp/compliance/controller/ComplianceController.java)
    - GET /api/compliance/audit-logs: @PreAuthorize(\"hasAuthority('COMPLIANCE_OFFICER')\")
      - Query parameters: entityType, entityId, actorId, startDate, endDate, page, size (default 20)
      - Return paginated list of AuditLogDTO
      - Filters applied: entityType (optional), createdAt between startDate and endDate, actorId (optional)
      - Sorting: created_at DESC (most recent first)
    - GET /api/compliance/audit-logs/{id}: @PreAuthorize(\"hasAuthority('COMPLIANCE_OFFICER')\")
      - Return single AuditLogDTO by ID
    - GET /api/compliance/audit-logs/user/{userId}: @PreAuthorize(\"hasAuthority('COMPLIANCE_OFFICER')\")
      - Return paginated list of actions by specific user
  - [ ] Error handling: 404 if audit log not found, 400 if date range invalid
  - [ ] Logging: log audit log access requests (who accessed which audit logs)
  - [ ] Unit tests: mock AuditLogRepository, test query filters
  - [ ] Integration tests: create audit entries, verify retrieval via API, test pagination

- [ ] Task 8: Add Audit Logging to Existing Controllers (AC: 2, 5)
  - [ ] Update AuthController:
    - Log USER_REGISTERED after successful user registration
    - Log USER_LOGGED_IN after successful login
    - Log USER_LOGGED_OUT after logout
    - Log PASSWORD_CHANGED after password change endpoint
  - [ ] Update BankRegistrationController (from Story 1.4):
    - Log BANK_REGISTERED after organization creation
    - Log BANK_ACTIVATED after activation endpoint
  - [ ] Inject AuditService and call logAction() with appropriate parameters
  - [ ] Include oldValues/newValues for profile updates (with sanitization)
  - [ ] Unit tests: mock AuditService, verify logAction() called with correct parameters

- [ ] Task 9: Create Immutability Constraint Enforcement (AC: 3)
  - [ ] Add database-level constraints to prevent deletion/updates:
    - CREATE TRIGGER audit_logs_no_delete BEFORE DELETE ON audit_logs FOR EACH ROW RAISE EXCEPTION 'Audit logs are immutable and cannot be deleted'
    - CREATE TRIGGER audit_logs_no_update BEFORE UPDATE ON audit_logs FOR EACH ROW RAISE EXCEPTION 'Audit logs are immutable and cannot be updated'
  - [ ] OR use application-level enforcement:
    - Override delete/update methods in AuditLogRepository to throw immutability exception
    - Create ImmutableEntityException (extends RuntimeException)
  - [ ] Test: attempt to delete/update audit log, verify exception thrown

- [ ] Task 10: Create Audit Log Retention Policy & Archival (AC: 7)
  - [ ] **BLOCKING DECISION RESOLVED**: Audit Log Archival Strategy
    - **Decision**: Archive table (MVP) → S3 archival (Production)
    - **Rationale**: Archive table keeps logs queryable for 3 years, S3 provides unlimited long-term storage at low cost
    - **MVP Strategy**: PostgreSQL archive_logs table, daily job moves logs > 3 years
    - **Production Strategy**: S3 archival with date-based partitioning, ElasticSearch index for queries
  - [ ] Create RetentionPolicyScheduler (src/main/java/com/creditapp/shared/scheduler/RetentionPolicyScheduler.java)
    - Use @Scheduled(cron = "0 0 2 * * ?") to run daily at 2 AM
    - Method: archiveOldAuditLogs()
      - Query audit_logs where created_at < (now - 3 years)
      - Insert into audit_logs_archive table (append-only, no delete from active)
      - Log archival event (number of records archived)
    - Note: Do NOT delete active logs before archival (complies with immutability and retention)
  - [ ] Create ArchivalService (src/main/java/com/creditapp/shared/service/ArchivalService.java)
    - Method: archiveAuditLogs(int yearsRetention) returns int
      - Configurable retention period (default 3 years)
      - Returns count of records moved to archive
    - Method: queryArchiveLogs(LocalDateTime start, LocalDateTime end) returns Page<AuditLog>
      - Query archive_logs table for historical data
  - [ ] Create database migration V*.sql for audit_logs_archive table (same schema as audit_logs)
  - [ ] Create configuration property: app.audit.retention.years=3 (default)
  - [ ] Unit tests: mock date, verify correct cutoff date calculation
  - [ ] Integration tests: verify archival process runs, data moved to archive table

- [ ] Task 11: Create Audit Logs Documentation (AC: 9)
  - [ ] Create docs/AUDIT_EVENTS.md documenting all audit event types:
    - Format: | Event | Description | Entity Type | Triggered By | Example |
    - USER_REGISTERED: New user account created | User | Registration endpoint | POST /api/auth/register
    - USER_LOGGED_IN: User authentication successful | User | Login endpoint | POST /api/auth/login
    - BANK_REGISTERED: New bank organization created | Organization | Bank registration endpoint | POST /api/auth/register-bank
    - BANK_ACTIVATED: Bank account activated via email | Organization | Activation endpoint | GET /api/auth/activate
    - PASSWORD_CHANGED: User changed password | User | Password change endpoint | PUT /api/profile/change-password
    - PROFILE_UPDATED: User updated profile | User | Profile update endpoint | PUT /api/profile
    - APPLICATION_SUBMITTED: Borrower submitted loan application | Application | Application endpoint | POST /api/applications
    - OFFER_CREATED: Bank created preliminary offer | Offer | Offer endpoint | POST /api/bank/offers
    - OFFER_ACCEPTED: Borrower accepted offer | Offer | Offer endpoint | PUT /api/applications/{id}/accept-offer
    - APPLICATION_VIEWED: Bank viewed application | Application | Queue endpoint | GET /api/bank/queue/{id}
    - ROLE_ASSIGNED: User role assigned/changed | User | Admin endpoint | (internal)
  - [ ] Include retention policy explanation (3 years minimum)
  - [ ] Include sanitization rules (passwords, tokens never logged)
  - [ ] Include query examples: filter by user, by date range, by action type

- [ ] Task 12: Create Integration Tests (AC: 8)
  - [ ] Create AuditLoggingIntegrationTest (src/test/java/com/creditapp/integration/compliance/AuditLoggingIntegrationTest.java)
    - Test 1: Register user, verify USER_REGISTERED audit log created with correct fields
    - Test 2: Login user, verify USER_LOGGED_IN audit log created
    - Test 3: Update profile, verify PROFILE_UPDATED audit log contains old and new values (sanitized)
    - Test 4: Change password, verify PASSWORD_CHANGED audit log created, verify password_hash not logged
    - Test 5: Query audit logs via API with filters (entityId, dateRange), verify results paginated
    - Test 6: Compliance officer can access audit logs, borrower gets 403 Forbidden
    - Test 7: Attempt to update/delete audit log, verify immutability exception raised
    - Test 8: Register bank and activate, verify BANK_REGISTERED and BANK_ACTIVATED audit logs created
    - Test 9: IP address and user agent captured correctly in audit log
    - Test 10: Pagination works: create 30 audit entries, verify page size and page navigation
  - [ ] Use TestContainers for PostgreSQL, TestRestTemplate for API tests
  - [ ] Mock email service (audit of email sends)

## Dev Notes

### Previous Stories Dependencies
- **Story 1.2**: AuditLog entity must integrate with existing User and Organization tables
- **Story 1.3**: USER_REGISTERED audit event logged after user registration
- **Story 1.5**: USER_LOGGED_IN audit event logged after successful login
- **Story 1.4**: BANK_REGISTERED and BANK_ACTIVATED events for bank registration flow

### Technology Stack
[Source: architecture/1-system-architecture-overview.md]
- **Framework**: Spring Boot 3.2.1, Spring Data JPA
- **Database**: PostgreSQL 15.4 with Flyway migrations
- **Audit Pattern**: **Hybrid - JPA EntityListeners + Spring AOP** (Blocking Decision 5)
  - JPA Listeners: Entity-level changes (user created, field updated)
  - AOP Aspects: Business-level events (application submitted, offer created)
  - Rationale: Clean separation of concerns, automatic capture of data changes

### Audit Schema Design
[Source: architecture/8-compliance-regulatory.md#82-audit-compliance]
`sql
CREATE TABLE audit_logs (
  id BIGSERIAL PRIMARY KEY,
  entity_type VARCHAR(100) NOT NULL,
  entity_id UUID NOT NULL,
  action VARCHAR(50) NOT NULL,
  actor_id UUID,
  actor_role VARCHAR(50),
  old_values JSONB,
  new_values JSONB,
  ip_address VARCHAR(45),
  user_agent VARCHAR(500),
  created_at TIMESTAMP DEFAULT NOW(),
  INDEX (entity_type, entity_id, created_at)
);
`

**Key Design Decisions:**
- JSONB for old_values/new_values allows flexible storage of any entity changes
- Immutable: no delete/update operations allowed
- Index on (entity_type, entity_id, created_at) for efficient queries
- Retention: 3-year minimum active, archive to S3 (Production)
- Append-only: only INSERT operations allowed

### Audit Event Types
[Source: architecture/8-compliance-regulatory.md and Story 1.7 AC]
- USER_REGISTERED: New borrower account created
- USER_LOGGED_IN: User authenticated successfully
- USER_LOGGED_OUT: User session ended
- PASSWORD_CHANGED: User changed password
- PROFILE_UPDATED: User updated personal information
- BANK_REGISTERED: Bank organization created
- BANK_ACTIVATED: Bank completed activation workflow
- APPLICATION_SUBMITTED: Borrower submitted loan application
- OFFER_CREATED: Bank created preliminary offer
- OFFER_ACCEPTED: Borrower accepted offer
- APPLICATION_VIEWED: Bank viewed application details
- ROLE_ASSIGNED: User role assigned or modified

### Data Sensitivity & Sanitization
[Source: architecture/4-security-architecture.md and architecture/8-compliance-regulatory.md]
**NEVER LOG:**
- Passwords or password hashes
- JWT tokens or refresh tokens
- API keys or secrets
- SSN (social security number)
- Full addresses (store only city/country)
- Full phone numbers (log only last 4 digits)
- Credit card numbers
- Bank account numbers

**SAFE TO LOG:**
- user_id (UUID)
- email address (first/last name with '*' for privacy)
- action performed
- timestamp
- IP address
- user agent
- entity IDs
- status changes

### Log Retention & Archival
[Source: architecture/7-monitoring-observability.md#72-logging-elk-stack]
- **Retention Duration**: 3-year minimum for audit logs (regulatory requirement)
- **Archival Strategy**: Move logs >3 years to S3 or separate archive database for long-term storage
- **Access**: Only COMPLIANCE_OFFICER role can view audit logs via API
- **Audit of Audits**: Log all audit log access (who viewed which audit logs and when)

### Project Directory Structure
[Source: Story 1.1 context]
`
src/main/java/com/creditapp/
 shared/
    model/                 # AuditLog.java, AuditAction.java
    repository/            # AuditLogRepository.java
    service/               # AuditService.java, RequestContextService.java
    dto/                   # AuditLogDTO.java, AuditLogRequest.java
    audit/                 # EntityAuditListener.java
    interceptor/           # AuditInterceptor.java
    scheduler/             # RetentionPolicyScheduler.java
    exception/             # ImmutableEntityException.java
 compliance/
    controller/            # ComplianceController.java

src/test/java/com/creditapp/
 integration/
    compliance/
      AuditLoggingIntegrationTest.java
`

### Testing Standards
[Source: frontend-architecture/10-testing-strategy.md]
- **Unit Tests**: Mock repositories, test AuditService sanitization and immutability
- **Integration Tests**: Real database (TestContainers), full audit workflows
- **Test Coverage**: All audit events, all filters, immutability constraints, pagination
- **Test Location**: src/test/java/com/creditapp/unit/ and src/test/java/com/creditapp/integration/

### Security Constraints
[Source: architecture/4-security-architecture.md]
- Only COMPLIANCE_OFFICER role can access /api/compliance/audit-logs endpoints
- Audit logs immutable: no delete/update operations
- IP address captured from HttpServletRequest (behind load balancer, use X-Forwarded-For header)
- Sensitive fields sanitized before storage
- Audit of audits: log who accessed which audit logs (for compliance verification)

### Important Notes
1. **Immutability First**: Design database constraints and application logic to prevent any modification of audit logs
2. **Sanitization**: Create comprehensive list of fields to exclude from audit trail (passwords, tokens, PII)
3. **Performance**: Index on (entity_type, entity_id, created_at) for efficient filtering and pagination
4. **Retention**: Implement archival mechanism to move old logs to S3 or separate table (do NOT delete)
5. **Audit of Audits**: Log all audit log API accesses (compliance requirement)
6. **Thread Safety**: RequestContext or ThreadLocal must be cleaned up properly to avoid context leakage
7. **Exception Handling**: Audit failures should log warning but NOT break application flow

## Testing

### Testing Framework & Location
- **Framework**: JUnit 5, Spring Boot Test, TestContainers
- **HTTP Client**: TestRestTemplate
- **Mocking**: Mockito for services
- **Test Location**: src/test/java/com/creditapp/unit/, src/test/java/com/creditapp/integration/

### Testing Checklist
- [ ] AuditLog entity: persists to database, immutable (no setter for createdAt)
- [ ] AuditLogRepository: CRUD operations work, custom query methods return correct results
- [ ] AuditService: logs actions correctly, sanitizes sensitive fields, handles exceptions gracefully
- [ ] RequestContextService: extracts IP and user agent from request correctly
- [ ] EntityAuditListener: captures field changes on insert/update, does not log sensitive fields
- [ ] AuditInterceptor: extracts and stores request context (IP, user agent)
- [ ] ComplianceController: /api/compliance/audit-logs returns paginated results, filters work, authentication enforced
- [ ] Immutability: database/application prevents delete/update on audit_logs
- [ ] USER_REGISTERED audit event created after user registration
- [ ] USER_LOGGED_IN audit event created after login
- [ ] PROFILE_UPDATED audit event contains old/new values (sanitized)
- [ ] PASSWORD_CHANGED audit event created, password_hash not in old/new values
- [ ] Retention policy: old logs archived after 3 years
- [ ] Pagination: works correctly with page/size parameters
- [ ] Authorization: only COMPLIANCE_OFFICER can access audit endpoints
- [ ] All tests pass with \mvn clean test\
- [ ] Code coverage >80%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-14 | 1.0 | Initial story draft - Audit Logging Infrastructure | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be completed by development agent*

### Debug Log References
*To be completed by development agent*

### Completion Notes
*To be completed by development agent*

### File List
*To be completed by development agent*

## QA Results

*To be completed by QA agent after story is implemented*
