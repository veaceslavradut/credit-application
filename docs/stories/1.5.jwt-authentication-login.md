# Story 1.5: JWT Authentication & Login

## Status
Ready for Development

## Story

**As a** borrower or bank administrator,
**I want** to log in with email and password and receive a secure authentication token,
**so that** subsequent API requests prove my identity without sending my password.

## Acceptance Criteria

1. POST /api/auth/login endpoint accepts email and password
2. Validates credentials against hashed password in database
3. On success: returns JWT token with claims (user_id, role, bank_id if bank admin)
4. JWT token includes: expiration (15 minutes), refresh token (7 days)
5. Token format: Bearer token sent in Authorization header for subsequent requests
6. Failed login attempts: no detailed error message ("Invalid email or password")
7. Account lockout after 5 failed login attempts (15-minute cooldown)
8. Refresh token endpoint: POST /api/auth/refresh extends session without re-entering password
9. Logout endpoint: POST /api/auth/logout invalidates refresh token
10. Integration test: login as borrower, verify token claims, use token to access protected endpoint

## Tasks / Subtasks

- [ ] Task 1: Create Login Request/Response DTOs (AC: 1, 3, 4)
  - [ ] Create LoginRequest DTO (src/main/java/com/creditapp/auth/dto/LoginRequest.java)
    - Fields: email, password
    - Validations: @NotBlank, @Email on email field
  - [ ] Create LoginResponse DTO (src/main/java/com/creditapp/auth/dto/LoginResponse.java)
    - Fields: accessToken, refreshToken, tokenType (\"Bearer\"), expiresIn (900 seconds = 15 min)
    - userId, email, role, organizationId (nullable for borrowers)
  - [ ] Create RefreshTokenRequest DTO (src/main/java/com/creditapp/auth/dto/RefreshTokenRequest.java)
    - Fields: refreshToken

- [ ] Task 2: Generate RSA Key Pair for JWT Signing (AC: 3, 5)
  - [ ] Generate RSA-256 key pair for JWT token signing
    - Use: keytool -genkeypair -alias jwtkey -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore jwt-keystore.p12 -validity 3650
    - Store keystore in src/main/resources/keystore/jwt-keystore.p12
    - Add keystore password to application.yml (externalize via environment variable for production)
  - [ ] Configure application.yml with JWT properties
    - jwt.keystore.location: classpath:keystore/jwt-keystore.p12
    - jwt.keystore.password: \
    - jwt.keystore.alias: jwtkey
    - jwt.access-token.expiration: 900 (15 minutes in seconds)
    - jwt.refresh-token.expiration: 604800 (7 days in seconds)
  - [ ] Add keystore to .gitignore (never commit production keys)
  - [ ] Document key generation process in README

- [ ] Task 3: Create JWT Token Service (AC: 3, 4, 8)
  - [ ] Create JwtTokenService (src/main/java/com/creditapp/auth/service/JwtTokenService.java)
    - Method: generateAccessToken(User user) returns String
      - Claims: sub (user_id), email, role, org_id (if bank admin), iat (issued at), exp (expiration)
      - Use RS256 algorithm with private key from keystore
      - Expiration: 15 minutes
    - Method: generateRefreshToken(User user) returns String
      - Claims: sub (user_id), iat, exp (7 days)
      - Store refresh token in Redis with key: refresh_token:{userId}:{tokenId}, TTL: 7 days
    - Method: validateAccessToken(String token) returns Claims
      - Verify signature with public key from keystore
      - Verify expiration
      - Throw InvalidTokenException if invalid or expired
    - Method: refreshAccessToken(String refreshToken) returns LoginResponse
      - Validate refresh token from Redis
      - Verify not expired
      - Generate new access token
      - Return LoginResponse with new access token (keep same refresh token)
  - [ ] Use io.jsonwebtoken:jjwt-api, jjwt-impl, jjwt-jackson libraries
  - [ ] Unit tests: token generation, validation, expiration handling

- [ ] Task 4: Create Redis Refresh Token Repository (AC: 4, 8, 9)
  - [ ] **BLOCKING DECISION RESOLVED**: Redis Storage for Temporary Data
    - **Decision**: Use Redis (primary) + in-memory fallback for development
    - **Storage**: All temporary data (tokens, failed login attempts, rate limiting) in Redis
    - **Rationale**: Distributed system requirement, already in Story 1.1 infrastructure, proven pattern
    - **Implementation**: Spring Data Redis with Lettuce client (default in Spring Boot 3.2.1)
    - **Key patterns**:
      - refresh_token:{userId}:{tokenId}        (TTL: 7 days)
      - failed_login:{email}                    (TTL: 15 minutes)
      - rate_limit:{borrowerId}:CREATE_APP      (TTL: 60 seconds)
  - [ ] Create RefreshToken entity (src/main/java/com/creditapp/auth/model/RefreshToken.java)
    - Fields: tokenId (UUID), userId (UUID), token (String), expiresAt (LocalDateTime), createdAt
  - [ ] Create RefreshTokenService (src/main/java/com/creditapp/auth/service/RefreshTokenService.java)
    - Method: save(UUID userId, String token) returns void
      - Store in Redis: key=refresh_token:{userId}:{uuid.randomUUID()}, value=token, TTL=7 days
    - Method: validate(String token) returns Optional<UUID> (returns userId if valid)
      - Query Redis for token, verify not expired
    - Method: invalidate(String token) returns void
      - Delete token from Redis (on logout)
  - [ ] Create RefreshTokenRepository using Spring Data Redis
    - Extends CrudRepository<RefreshToken, String>
    - Store in Redis with key pattern: refresh_token:{userId}:{tokenId}
    - TTL: 7 days (auto-expires)
    - Methods: save(RefreshToken), findByToken(String), deleteByToken(String), deleteAllByUserId(UUID)
  - [ ] Configure Redis connection in application.yml (already from Story 1.1)
    - spring.redis.host: localhost (dev), environment variable (prod)
    - spring.redis.port: 6379
    - spring.redis.password: environment variable (if required, optional for MVP)
  - [ ] Unit tests: save/retrieve refresh tokens from Redis, verify TTL behavior

- [ ] Task 5: Create Failed Login Attempts Tracker (AC: 7)
  - [ ] **Redis-backed Implementation** (part of Blocking Decision 2: Redis Storage)
  - [ ] Create LoginAttemptService (src/main/java/com/creditapp/auth/service/LoginAttemptService.java)
    - Store failed attempts in Redis: failed_login:{email} with count and TTL: 15 minutes
    - Method: recordFailedLogin(String email)
      - Get current count from Redis (key: failed_login:{email})
      - Increment count
      - If first attempt, set TTL to 15 minutes
      - If count >= 5, account is locked
    - Method: resetFailedLogins(String email)
      - Delete failed_login:{email} key from Redis
    - Method: isAccountLocked(String email) returns boolean
      - Check if failed_login:{email} count >= 5
      - Return true if locked, false otherwise
    - Method: getRemainingLockoutTime(String email) returns Duration
      - Get TTL (PTTL) of failed_login:{email} key from Redis
  - [ ] Unit tests: failed login tracking, lockout logic, Redis key expiration

- [ ] Task 6: Create Authentication Service (AC: 1, 2, 6, 7)
  - [ ] Create AuthenticationService (src/main/java/com/creditapp/auth/service/AuthenticationService.java)
    - Method: login(LoginRequest request) returns LoginResponse
      - Check if account locked via LoginAttemptService.isAccountLocked(email)
      - Throw AccountLockedException if locked (include remaining lockout time in message)
      - Find user by email in database
      - Verify password using PasswordHasher.matches(plainPassword, user.passwordHash)
      - If password invalid:
        - Call LoginAttemptService.recordFailedLogin(email)
        - Throw InvalidCredentialsException with generic message: \"Invalid email or password\"
      - If password valid:
        - Call LoginAttemptService.resetFailedLogins(email)
        - Generate access token and refresh token via JwtTokenService
        - Return LoginResponse with tokens and user info
    - Method: logout(String refreshToken)
      - Delete refresh token from Redis via RefreshTokenRepository
      - Return success message
  - [ ] Unit tests: login success, login failure, account lockout

- [ ] Task 7: Create Login REST Controller (AC: 1, 8, 9)
  - [ ] Create endpoint in AuthController: POST /api/auth/login
    - Accept: LoginRequest (JSON)
    - Return: LoginResponse with HTTP 200 OK
    - Call AuthenticationService.login()
    - Error handling:
      - 401 Unauthorized: invalid credentials, account locked
      - 400 Bad Request: validation errors (missing email, invalid format)
      - 500 Internal Server Error: unexpected failures
    - Log all login attempts (email, IP, success/failure) for audit
  - [ ] Create endpoint in AuthController: POST /api/auth/refresh
    - Accept: RefreshTokenRequest (JSON)
    - Return: LoginResponse with new access token
    - Call JwtTokenService.refreshAccessToken()
    - Error handling: 401 Unauthorized if refresh token invalid or expired
  - [ ] Create endpoint in AuthController: POST /api/auth/logout
    - Accept: Authorization header with Bearer token (extract refresh token from request body)
    - Call AuthenticationService.logout()
    - Return: 204 No Content on success
  - [ ] Use @Valid annotation on request parameters
  - [ ] Unit tests: mock AuthenticationService, test success and error paths

- [ ] Task 8: Configure JWT Filter for Protected Endpoints (AC: 5)
  - [ ] Create JwtAuthenticationFilter (src/main/java/com/creditapp/shared/security/JwtAuthenticationFilter.java)
    - Extends OncePerRequestFilter
    - Extract Authorization header from request
    - Validate Bearer token format: \"Bearer {token}\"
    - Call JwtTokenService.validateAccessToken(token)
    - Extract user_id, role from token claims
    - Load UserDetails from database
    - Set Authentication in SecurityContext
    - If token invalid or expired: return 401 Unauthorized
  - [ ] Register filter in SecurityConfig before UsernamePasswordAuthenticationFilter
  - [ ] Configure SecurityConfig:
    - Permit /api/auth/register, /api/auth/login, /api/auth/refresh without authentication
    - Require authentication for all other /api/** endpoints
  - [ ] Unit tests: valid token, expired token, missing token, invalid signature

- [ ] Task 9: Create Custom Exception Handlers (AC: 6)
  - [ ] Create custom exceptions:
    - InvalidCredentialsException (extends RuntimeException)
    - AccountLockedException (extends RuntimeException) - includes remaining lockout time
    - InvalidTokenException (extends RuntimeException)
  - [ ] Update GlobalExceptionHandler from Story 1.3
    - @ExceptionHandler for InvalidCredentialsException  401 Unauthorized
    - @ExceptionHandler for AccountLockedException  401 Unauthorized (message: \"Account temporarily locked. Try again in X minutes.\")
    - @ExceptionHandler for InvalidTokenException  401 Unauthorized

- [ ] Task 10: Create Integration Tests (AC: 10)
  - [ ] Create AuthenticationIntegrationTest (src/test/java/com/creditapp/integration/auth/AuthenticationIntegrationTest.java)
    - Test 1: Happy path - register borrower, login with valid credentials, verify LoginResponse contains tokens
    - Test 2: Verify access token contains correct claims: user_id, role, email
    - Test 3: Use access token to call protected endpoint (GET /api/profile), verify 200 OK
    - Test 4: Call protected endpoint without token, verify 401 Unauthorized
    - Test 5: Call protected endpoint with expired token, verify 401 Unauthorized
    - Test 6: Failed login with invalid password, verify 401 Unauthorized with generic message
    - Test 7: 5 failed login attempts, verify account locked, verify 401 on 6th attempt with lockout message
    - Test 8: Wait 15 minutes (simulate with Redis TTL), verify account unlocked and login succeeds
    - Test 9: Refresh token flow - login, use refresh token to get new access token, verify new token works
    - Test 10: Logout flow - login, logout with refresh token, verify refresh token invalidated, verify cannot refresh with old token
    - Test 11: Login as bank admin, verify token includes organizationId claim
  - [ ] Use TestContainers for PostgreSQL and Redis, real HTTP client (TestRestTemplate)
  - [ ] Mock time for expiration testing (optional)

- [ ] Task 11: Add Dependencies to pom.xml (AC: 3, 4)
  - [ ] **BLOCKING DECISION RESOLVED**: JWT Library Version
    - **Decision**: Pin JJWT 0.11.5 (stable, proven in production)
    - **Rationale**: 0.11.5 is battle-tested, no breaking changes. 0.12.x has API changes not worth delaying Sprint 2
    - **Upgrade Path**: Plan 0.12.x migration as separate post-MVP story
  - [ ] Add JWT library:
    - io.jsonwebtoken:jjwt-api:0.11.5
    - io.jsonwebtoken:jjwt-impl:0.11.5
    - io.jsonwebtoken:jjwt-jackson:0.11.5
  - [ ] Add Spring Data Redis (if not already present from Story 1.1):
    - spring-boot-starter-data-redis
    - io.lettuce:lettuce-core:7.2.3 (already from Story 1.1)
  - [ ] Add Spring Security (if not already present)
    - spring-boot-starter-security
  - [ ] Verify all dependencies resolve and project builds
  - [ ] Document: jwt library pinned to 0.11.5 in README (note: 0.12.x upgrade planned post-MVP)

- [ ] Task 12: Create API Documentation (AC: 1, 8, 9)
  - [ ] Update docs/API_ENDPOINTS.md
    - POST /api/auth/login
    - Request: { \"email\": \"user@example.com\", \"password\": \"SecurePass123!\" }
    - Response (200): { \"accessToken\": \"eyJhbGc...\", \"refreshToken\": \"eyJhbGc...\", \"tokenType\": \"Bearer\", \"expiresIn\": 900, \"userId\": \"550e8400-e29b-41d4-a716-446655440000\", \"email\": \"user@example.com\", \"role\": \"BORROWER\" }
    - Error responses: 401 (invalid credentials, account locked), 400 (validation errors)
    - POST /api/auth/refresh
    - Request: { \"refreshToken\": \"eyJhbGc...\" }
    - Response (200): { \"accessToken\": \"eyJhbGc...\", \"refreshToken\": \"eyJhbGc...\", \"tokenType\": \"Bearer\", \"expiresIn\": 900 }
    - POST /api/auth/logout
    - Request: { \"refreshToken\": \"eyJhbGc...\" }
    - Response (204): No Content
    - Protected endpoint usage example: GET /api/profile with \"Authorization: Bearer {accessToken}\" header

## Dev Notes

### Previous Story Insights
- **Story 1.2**: Database schema created with users table, UserRepository available
- **Story 1.3**: User registration implemented with bcrypt password hashing (PasswordHasher service), User entity with role field (BORROWER, BANK_ADMIN)
- **Story 1.4**: Bank admin registration with organizationId linking, bank activation workflow

### Technology Stack
[Source: architecture/1-system-architecture-overview.md]
- **Backend Framework**: Spring Boot 3.2.1, Spring Security
- **JWT Library**: io.jsonwebtoken (jjwt) 0.11.5
- **Cache/Session Store**: Redis 7.2.3 for refresh tokens and failed login tracking
- **Signature Algorithm**: RS256 (RSA with SHA-256)
- **Key Management**: RSA key pair stored in PKCS12 keystore

### Authentication Flow Architecture
[Source: architecture/4-security-architecture.md]
`
1. User submits email + password
2. Backend validates (bcrypt verify)
3. Generate JWT with claims: sub, role, org_id, exp (15 min)
4. Return access_token + refresh_token (7 days, stored in Redis)
5. Client includes access_token in Authorization header
6. API Gateway validates JWT signature (RS256) + expiration
`

### JWT Token Specifications
[Source: architecture/2-detailed-service-architecture.md, architecture/4-security-architecture.md]
- **Access Token**:
  - Algorithm: RS256 (RSA signature with SHA-256)
  - Expiration: 15 minutes
  - Claims: sub (user_id), email, role, org_id (if bank admin), iat, exp
  - Transmitted in Authorization header: \"Bearer {token}\"
- **Refresh Token**:
  - Expiration: 7 days
  - Stored in Redis with key: refresh_token:{userId}:{tokenId}
  - Claims: sub (user_id), iat, exp
  - Used to obtain new access token without re-entering password
  - Revoked on logout

### Security Requirements
[Source: architecture/4-security-architecture.md]
- **Password Validation**: bcrypt with salt factor 12 (implemented in Story 1.3)
- **Failed Login Handling**: 
  - Track failed attempts per email in Redis
  - Lockout after 5 failed attempts
  - 15-minute cooldown period
  - Generic error message: \"Invalid email or password\" (no user enumeration)
- **Token Revocation**: Refresh tokens stored in Redis can be deleted on logout
- **Session Management**: Refresh tokens in Redis with 7-day TTL (auto-expire)

### API Endpoints Specification
[Source: architecture/2-detailed-service-architecture.md]
`
POST   /api/auth/login        # JWT authentication
POST   /api/auth/refresh      # Refresh JWT token
POST   /api/auth/logout       # Logout & revoke token
`

**Login Request:**
`json
{
  \"email\": \"user@example.com\",
  \"password\": \"SecurePass123!\"
}
`

**Login Response (200 OK):**
`json
{
  \"accessToken\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",
  \"refreshToken\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",
  \"tokenType\": \"Bearer\",
  \"expiresIn\": 900,
  \"userId\": \"550e8400-e29b-41d4-a716-446655440000\",
  \"email\": \"user@example.com\",
  \"role\": \"BORROWER\",
  \"organizationId\": null
}
`

**Error Response (401 Unauthorized):**
`json
{
  \"error\": \"Unauthorized\",
  \"message\": \"Invalid email or password\"
}
`

**Error Response (401 - Account Locked):**
`json
{
  \"error\": \"Unauthorized\",
  \"message\": \"Account temporarily locked due to multiple failed login attempts. Try again in 12 minutes.\"
}
`

### Redis Storage Pattern
[Source: architecture/6-performance-scalability.md]
- **Refresh Tokens**: 
  - Key pattern: 
efresh_token:{userId}:{tokenId}
  - Value: JSON with token, expiresAt, createdAt
  - TTL: 7 days (604800 seconds)
- **Failed Login Attempts**:
  - Key pattern: ailed_login:{email}
  - Value: count (integer)
  - TTL: 15 minutes (900 seconds)

### Project Directory Structure
[Source: Story 1.1 context]
`
src/main/java/com/creditapp/
 auth/
    controller/        # AuthController.java (add login, refresh, logout endpoints)
    service/           # AuthenticationService.java, JwtTokenService.java, LoginAttemptService.java
    dto/               # LoginRequest.java, LoginResponse.java, RefreshTokenRequest.java
    model/             # RefreshToken.java
    repository/        # RefreshTokenRepository.java (Spring Data Redis)
 shared/
    security/          # JwtAuthenticationFilter.java, SecurityConfig.java
    config/            # RedisConfig.java (if needed)
    exception/         # InvalidCredentialsException.java, AccountLockedException.java, InvalidTokenException.java

src/main/resources/
 keystore/             # jwt-keystore.p12 (RSA key pair for signing)
 application.yml       # JWT and Redis configuration

src/test/java/com/creditapp/
 integration/
    auth/
      AuthenticationIntegrationTest.java
`

### Key Dependencies
`xml
<!-- JWT Library -->
<dependency>
  <groupId>io.jsonwebtoken</groupId>
  <artifactId>jjwt-api</artifactId>
  <version>0.11.5</version>
</dependency>
<dependency>
  <groupId>io.jsonwebtoken</groupId>
  <artifactId>jjwt-impl</artifactId>
  <version>0.11.5</version>
  <scope>runtime</scope>
</dependency>
<dependency>
  <groupId>io.jsonwebtoken</groupId>
  <artifactId>jjwt-jackson</artifactId>
  <version>0.11.5</version>
  <scope>runtime</scope>
</dependency>

<!-- Spring Security -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- Spring Data Redis -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
`

### Testing Standards
[Source: frontend-architecture/10-testing-strategy.md]
- **Unit Tests**: Mock UserRepository, RefreshTokenRepository, Redis operations
- **Integration Tests**: Real database (TestContainers PostgreSQL), real Redis (TestContainers), real HTTP client (TestRestTemplate)
- **Test Coverage**: Login flow, token generation/validation, refresh flow, logout, failed login tracking, account lockout
- **Test Location**: src/test/java/com/creditapp/unit/ (unit), src/test/java/com/creditapp/integration/ (integration)

### Important Notes
1. **Key Management**: RSA key pair must be generated before running application. Document generation in README.
2. **Environment Variables**: Keystore password, Redis password must be externalized for production
3. **Token Claims**: organizationId claim MUST be included for bank admins (used for authorization in later stories)
4. **Rate Limiting**: Login endpoint should be rate-limited (10 requests/minute per IP) - implement in later story or as part of API gateway
5. **Audit Logging**: All login attempts (success/failure) must be logged for compliance (Story 1.7)
6. **Security**: NEVER return detailed error messages that could enable user enumeration (\"User not found\" vs \"Invalid email or password\")

## Testing

### Testing Framework & Location
- **Framework**: JUnit 5, Spring Boot Test, TestContainers (PostgreSQL, Redis)
- **HTTP Client**: TestRestTemplate
- **Mocking**: Mockito
- **Test Location**: src/test/java/com/creditapp/unit/, src/test/java/com/creditapp/integration/

### Testing Checklist
- [ ] JwtTokenService: generates valid access token with correct claims
- [ ] JwtTokenService: validates access token signature and expiration
- [ ] JwtTokenService: generates and stores refresh token in Redis
- [ ] JwtTokenService: refreshes access token using valid refresh token
- [ ] LoginAttemptService: tracks failed login attempts and enforces lockout
- [ ] AuthenticationService: validates credentials and returns LoginResponse
- [ ] AuthenticationService: handles invalid credentials with generic error message
- [ ] AuthenticationService: enforces account lockout after 5 failed attempts
- [ ] Login endpoint: POST /api/auth/login succeeds with valid credentials, returns 200
- [ ] Login endpoint: invalid credentials return 401 with generic message
- [ ] Login endpoint: locked account returns 401 with lockout message
- [ ] Refresh endpoint: POST /api/auth/refresh succeeds with valid refresh token
- [ ] Refresh endpoint: invalid/expired refresh token returns 401
- [ ] Logout endpoint: POST /api/auth/logout invalidates refresh token
- [ ] JwtAuthenticationFilter: extracts and validates token from Authorization header
- [ ] JwtAuthenticationFilter: rejects requests without token (401)
- [ ] JwtAuthenticationFilter: rejects requests with expired token (401)
- [ ] Integration test: full login flow with database and Redis
- [ ] Integration test: use access token to access protected endpoint
- [ ] All tests pass with mvn clean test
- [ ] Code coverage >80%

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-14 | 1.0 | Initial story draft - JWT Authentication & Login | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
*To be completed by development agent*

### Debug Log References
*To be completed by development agent*

### Completion Notes
*To be completed by development agent*

### File List
*To be completed by development agent*

## QA Results

*To be completed by QA agent after story is implemented*
